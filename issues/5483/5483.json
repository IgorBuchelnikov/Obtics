{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "I've come across an implementation problem with using Obtics on a background thread with a DependencyObject on the UI thread and am wondering if you've come across it and how you think it should be handled.\n \nI have a property that is computed using Obtics on a separate thread.  At some point after a change event occurs on an object used in the Obtics expression, the expression needs to use the UI's Dispatcher to get to the UI thread (e.g. to get and set a DependencyProperty value).\nThe problem I have is that every way I've tried to do this *after* the change event occurs, Obtics is stuck on the Main thread in a lock and so the background thread can't use the main thread to do its thing.  Here is a partial stack trace of the Main thread and the background thread.  On the main thread, Obtics is stuck in a sleep loop waiting for some flag to be set and the background thread is stuck waiting for the Main thread to be free for use:\n>\tObtics.dll!Obtics.ObservableObjectBase.Lock() Line 113 + 0x7 bytes\tC#\n \tObtics.dll!Obtics.NCSourcedObjectToVE<Npipm.Compas.ViewModels.UserScheduleViewModel,Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.CollectionChanged.add(System.Collections.Specialized.NotifyCollectionChangedEventHandler value = {Method = Cannot evaluate expression because the code of the current method is optimized.}) Line 167 + 0x8 bytes\tC#\n \tPresentationFramework.dll!System.Windows.Data.CollectionView.CollectionView(System.Collections.IEnumerable collection = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, int moveToFirst = -1) + 0x12b bytes\t\n \tPresentationFramework.dll!MS.Internal.Data.EnumerableCollectionView.EnumerableCollectionView(System.Collections.IEnumerable source = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}) + 0x15 bytes\t\n \tPresentationFramework.dll!MS.Internal.Data.ViewManager.GetViewRecord(object collection = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, System.Windows.Data.CollectionViewSource cvs = {System.Windows.Data.CollectionViewSource}, System.Type collectionViewType, bool createView) + 0x12c bytes\t\n \tPresentationFramework.dll!MS.Internal.Data.DataBindEngine.GetViewRecord(object collection, System.Windows.Data.CollectionViewSource key, System.Type collectionViewType, bool createView) + 0x1f bytes\t\n \tPresentationFramework.dll!System.Windows.Data.CollectionViewSource.GetDefaultCollectionView(object source, bool createView) + 0x43 bytes\t\n \tPresentationFramework.dll!System.Windows.Data.CollectionViewSource.GetDefaultCollectionView(object source, System.Windows.DependencyObject d = {System.Windows.Controls.ListBox}) + 0x28 bytes\t\n \tPresentationFramework.dll!System.Windows.Controls.ItemCollection.SetItemsSource(System.Collections.IEnumerable value) + 0x38 bytes\t\n \tPresentationFramework.dll!System.Windows.Controls.ItemsControl.OnItemsSourceChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e) + 0xad bytes\t\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e) + 0x4a bytes\t\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e) + 0x50 bytes\t\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args) + 0x2c bytes\t\n \tWindowsBase.dll!System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex entryIndex = {System.Windows.EntryIndex}, System.Windows.DependencyProperty dp = {System.Windows.DependencyProperty}, System.Windows.PropertyMetadata metadata, System.Windows.EffectiveValueEntry oldEntry, ref System.Windows.EffectiveValueEntry newEntry = {System.Windows.EffectiveValueEntry}, bool coerceWithDeferredReference, System.Windows.OperationType operationType) + 0x515 bytes\t\n \tWindowsBase.dll!System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty dp) + 0xa2 bytes\t\n \tPresentationFramework.dll!System.Windows.Data.BindingExpression.Invalidate(bool isASubPropertyChange) + 0x60 bytes\t\n \tPresentationFramework.dll!System.Windows.Data.BindingExpression.TransferValue(object newValue, bool isASubPropertyChange) + 0x1c4 bytes\t\n \tPresentationFramework.dll!System.Windows.Data.BindingExpression.Activate(object item) + 0xe7 bytes\t\n \tPresentationFramework.dll!System.Windows.Data.BindingExpression.AttachToContext(System.Windows.Data.BindingExpression.AttachAttempt attempt) + 0x1de bytes\t\n \tPresentationFramework.dll!System.Windows.Data.BindingExpression.MS.Internal.Data.IDataBindEngineClient.AttachToContext(bool lastChance) + 0x19 bytes\t\n \tPresentationFramework.dll!MS.Internal.Data.DataBindEngine.Task.Run(bool lastChance = false) + 0x31 bytes\t\n \tPresentationFramework.dll!MS.Internal.Data.DataBindEngine.Run(object arg) + 0xb7 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback = {Method = Cannot evaluate expression because the code of the current method is optimized.}, object args = false, bool isSingleParameter = true) + 0x8a bytes\t\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source = {System.Windows.Threading.Dispatcher}, System.Delegate callback, object args, bool isSingleParameter, System.Delegate catchHandler = null) + 0x4a bytes\t\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WrappedInvoke(System.Delegate callback, object args, bool isSingleParameter, System.Delegate catchHandler) + 0x44 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl() + 0x5d bytes\t\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state) + 0x38 bytes\t\n \tmscorlib.dll!System.Threading.ExecutionContext.runTryCode(object userData) + 0x51 bytes\t\n \n \nAnd then here is where the background thread is deadlocked waiting for the Main thread:\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Invoke(System.Delegate method, object[] args) + 0x3f bytes\t\n \n \t[Lightweight Function]\t\n \tObtics.dll!Obtics.Collections.Transformations.ConvertTransformation<CompasBiz.Scheduling.User,Npipm.Compas.ViewModels.UserScheduleViewModel>.ConvertValue(CompasBiz.Scheduling.User value = {CompasBiz.Scheduling.User}) Line 40 + 0x1a bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.ConvertTransformationBase<CompasBiz.Scheduling.User,Npipm.Compas.ViewModels.UserScheduleViewModel,Obtics.Collections.IVersionedEnumerable<CompasBiz.Scheduling.User>,Obtics.Tuple<Obtics.Collections.IVersionedEnumerable<CompasBiz.Scheduling.User>,System.Func<CompasBiz.Scheduling.User,Npipm.Compas.ViewModels.UserScheduleViewModel>>>.ConvertEnumerator.MoveNext() Line 23 + 0x73 bytes\tC#\n \tObtics.dll!Obtics.Collections.VersionedEnumerator.EnumeratorWrapper<Npipm.Compas.ViewModels.UserScheduleViewModel>.MoveNext() Line 57 + 0xd bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>.BufferNodeCC.BufferNodeCC(System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel> rawCollection = {Obtics.Collections.Transformations.ConvertTransformation<CompasBiz.Scheduling.User,Npipm.Compas.ViewModels.UserScheduleViewModel>}, Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>> owner = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}) Line 73 + 0x9 bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>.RefreshBuffer() Line 150 + 0xc7 bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>.UpdateHaveChangedListeningClients(bool newValue = true, bool oldValue = false) Line 174 + 0x8 bytes\tC#\n \tObtics.dll!Obtics.NCObservableObjectBase<Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.HaveChangedListeningClients.set(bool value = true) Line 101 + 0xf bytes\tC#\n \tObtics.dll!Obtics.NCObservableObjectBase<Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.SubscribeINC(Obtics.IReceiveChangeNotification receiver = Count = Cannot evaluate expression because the current thread is in a sleep, wait, or join) Line 157 + 0x28 bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>.BufferNodeCC.BufferNodeCC(System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel> rawCollection = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>> owner = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}) Line 67 + 0xc bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>.RefreshBuffer() Line 150 + 0xc7 bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>.ResultInformationExposed() Line 180 + 0x8 bytes\tC#\n \tObtics.dll!Obtics.NCSourcedObjectToVE<Npipm.Compas.ViewModels.UserScheduleViewModel,Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.GetEnumerator() Line 88 + 0x8 bytes\tC#\n \tObtics.dll!Obtics.NCSourcedObjectToVE<Npipm.Compas.ViewModels.UserScheduleViewModel,Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.System.Collections.Generic.IEnumerable<TOut>.GetEnumerator() Line 45 + 0x9 bytes\tC#\n \tSystem.Core.dll!System.Linq.Enumerable.Count<Npipm.Compas.ViewModels.UserScheduleViewModel>(System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel> source) + 0xb2 bytes\t\n \tNpipm.Compas.Wpf.exe!Npipm.Compas.ViewModels.MainViewModel.InitializeDefaults() Line 480 + 0x1a bytes\tBasic\n \tNpipm.Compas.Wpf.exe!Npipm.Compas.ViewModels.MainViewModel.OnUsersWithSchedulesCollectionChanged(Object sender = {Obtics.Collections.Transformations.CascadeTransformation(Of Npipm.Compas.ViewModels.UserScheduleViewModel, System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel))}, System.Collections.Specialized.NotifyCollectionChangedEventArgs e = {Obtics.Collections.OrderedNotifyCollectionChangedEventArgs}) Line 341 + 0xa bytes\tBasic\n \tObtics.dll!Obtics.NCToNCC.NotifyChanged(object sender = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, Obtics.INCEventArgs changeArgs = {Obtics.INCollectionResetEventArgs}) Line 150 + 0x20 bytes\tC#\n \tObtics.dll!Obtics.NotifyChangedReceiverTable.SendMessage(object sender = {Obtics.Collections.Transformations.CascadeTransformation<Npipm.Compas.ViewModels.UserScheduleViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, Obtics.INCEventArgs message = {Obtics.INCollectionResetEventArgs}) Line 355 + 0xf bytes\tC#\n \tObtics.dll!Obtics.NCObservableObjectBase<Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.Release(Obtics.INCEventArgs message = {Obtics.INCollectionResetEventArgs}) Line 227 + 0x13 bytes\tC#\n \tObtics.dll!Obtics.Collections.Transformations.OpaqueTransformationBase<Npipm.Compas.ViewModels.UserScheduleViewModel,Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>,Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.Release(Obtics.INCEventArgs message = {Obtics.INCollectionResetEventArgs}) Line 106 + 0xb bytes\tC#\n \tObtics.dll!Obtics.NCSourcedObject<Obtics.Collections.IVersionedEnumerable<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.NotifyChanged(object sender = {Obtics.Values.Transformations.AsCollectionNullableTransformation<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, Obtics.INCEventArgs args = {Obtics.INCollectionResetEventArgs}) Line 144 + 0xb bytes\tC#\n \tObtics.dll!Obtics.NotifyChangedReceiverTable.SendMessage(object sender = {Obtics.Values.Transformations.AsCollectionNullableTransformation<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, Obtics.INCEventArgs message = {Obtics.INCollectionResetEventArgs}) Line 355 + 0xf bytes\tC#\n \tObtics.dll!Obtics.NCObservableObjectBase<Obtics.Tuple<Obtics.Values.IInternalValueProvider<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>,System.Func<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>,bool>>>.Release(Obtics.INCEventArgs message = {Obtics.INCollectionResetEventArgs}) Line 227 + 0x13 bytes\tC#\n \tObtics.dll!Obtics.NCSourcedObject<Obtics.Tuple<Obtics.Values.IInternalValueProvider<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>,System.Func<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>,bool>>>.NotifyChanged(object sender = {Obtics.Values.Transformations.NPCToNC<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, Obtics.INCEventArgs args = {Obtics.INPropertyChangedEventArgs}) Line 144 + 0xb bytes\tC#\n \tObtics.dll!Obtics.NotifyChangedReceiverTable.SendMessage(object sender = {Obtics.Values.Transformations.NPCToNC<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, Obtics.INCEventArgs message = {Obtics.INPropertyChangedEventArgs}) Line 355 + 0xf bytes\tC#\n \tObtics.dll!Obtics.NCObservableObjectBase<Obtics.Values.IValueProvider<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.Release(Obtics.INCEventArgs message = {Obtics.INPropertyChangedEventArgs}) Line 227 + 0x13 bytes\tC#\n \tObtics.dll!Obtics.NCObservableObjectBase<Obtics.Values.IValueProvider<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.Release(object rawMessage = {Obtics.INPropertyChangedEventArgs}) Line 187 + 0xb bytes\tC#\n \tObtics.dll!Obtics.Values.Transformations.NPCToNCBase<Obtics.Values.IValueProvider<System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>>.npc_PropertyChanged(object sender = {Npipm.AsyncValueProvider<Npipm.Compas.ViewModels.MainViewModel,System.Collections.Generic.IEnumerable<Npipm.Compas.ViewModels.UserScheduleViewModel>>}, System.ComponentModel.PropertyChangedEventArgs e = {System.ComponentModel.PropertyChangedEventArgs}) Line 29 + 0xcc bytes\tC#\n \tNpipm.dll!Npipm.ObjectModel.ObservableObject.NotifyPropertyChanged(String propertyName = \"Value\") Line 26 + 0x3c bytes\tBasic\n \tNpipm.WinFx.dll!Npipm.ObjectModel.DispatcherNotifiedObservableObject.NotifyPropertyChanged(String propertyName = \"Value\") Line 31 + 0xb bytes\tBasic\n \tNpipm.dll!Npipm.ObjectModel.ObservableObject.NotifyPropertyChanged(Of System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel))(System.Linq.Expressions.Expression(Of System.Func(Of System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel))) expression = {System.Linq.Expressions.Expression(Of System.Func(Of System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel)))}) Line 38 + 0x5c bytes\tBasic\n \tNpipm.WinFx.dll!Npipm.ValueProviderBaseBase(Of T).NotifyValueChanged() Line 27 + 0x1cc bytes\tBasic\n \tNpipm.WinFx.dll!Npipm.AttachedValueProviderBase(Of TOwner, T).set_Value(System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel) value = {Obtics.Collections.Transformations.CascadeTransformation(Of Npipm.Compas.ViewModels.UserScheduleViewModel, System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel))}) Line 98 + 0x8 bytes\tBasic\n \tNpipm.WinFx.dll!Npipm.AsyncValueProvider(Of TOwner, T).set_Value(System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel) value = {Obtics.Collections.Transformations.CascadeTransformation(Of Npipm.Compas.ViewModels.UserScheduleViewModel, System.Collections.Generic.IEnumerable(Of Npipm.Compas.ViewModels.UserScheduleViewModel))}) Line 66 + 0xb bytes\tBasic\n \tNpipm.WinFx.dll!Npipm.AsyncValueProvider(Of TOwner, T).LoadAsyncValue() Line 84 + 0x68 bytes\tBasic\n \nThe only working solution I've found so far is to Dispatch the INotifyPropertyChanged event, itself, to the Main thread, so that *all* Obtics code runs on the Main thread instead of the background thread.  But this defeats most of the advantages of having another thread at all, since most of the processing still occurs on the Main thread.\n \nSo to simplify my question: I basically want to know the best way to use Obtics on a non-UI thread that needs to access the UI thread in mid-expression.",
    "LastUpdatedDate": "2013-02-13T18:41:06.087-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "Obtics",
    "ReportedDate": "2009-11-20T05:39:41.36-08:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Multithreading & DependencyObject",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 5483
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Did you check out the GroupingTest, ObticsUnitTestRunner_SilverLight or ObticsRaytracer examples? They all work with background threads. \r\n\r\nI think the easiest way would be to bind your dependency property to a ValueProvider.Dynamic<T>().Async() construct and use that in your background process. Wrap the end result of your observable expression in an Async() as well before you bind to it.\r\n\r\nHope that helps? \r\n",
      "PostedDate": "2009-11-20T10:22:38.103-08:00",
      "Id": -2147483648
    },
    {
      "Message": "I'm trying your suggestion of using .Async().  However, in this case, the Main thread is stuck while evaluating a CascadingTransformation.  Since this is not an IValueProvider, it does not have the .Async() method on it.  \r\n\r\nHow would you accomplish the functionality of .Async() on an instance of the CascadingTransformation type?",
      "PostedDate": "2009-11-20T16:15:38.523-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Sorry, ignore that last comment.  I didn't have the \"Obtics.Collections\" namespace included so .Async didn't show up in Intellisense for IEnumerable.",
      "PostedDate": "2009-11-20T16:34:33.893-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Worked beautifully, thank you!",
      "PostedDate": "2009-11-20T17:02:14.537-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Nevermind, it wasn't that simple.  .Async(), by default, enqueues changes to be execute via a shared Dispatcher, which happens to be the one provided by the UI thread.  So adding .Async() only fixed it by removing the multiple threads.\r\n\r\nHowever, I found the class WorkQueueOnThreadPoolProvider, of which, I think I need to pass an instance to .Async().  However, when I do this, I still have the exact problem as when I don't use .Async().",
      "PostedDate": "2009-11-20T21:10:53.34-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Async() without any arguments uses the Dispatcher of the thread calling it. So if the UI thread calls it it will use the UI thread dispatcher. If any of your background threads accesses it it will use the dispatcher of that background thread. This is unproper behaviour I must admit and I think functionality will have to change so that the UI dispatcher only is used.\r\n\r\nSomething like this will be proper and probably give the desired result:\r\n\r\nclass A\r\n{\r\n\tIValueProvider<T> _Store = ValueProvider.Dynamic<T>();\r\n\r\n\t//bind your dependency property here\r\n\tpublic IValueProvider<T> UIConnectionPoint\r\n\t{ get{ return _Store.Async(WorkQueueOnDispatcherAdapter.Get(Application.Current.Dispatcher,DispatcherPriority.Binding)); } }\r\n\r\n\t//build your background working expression on this\r\n\tpublic IValueProvider<T> MTConnectionPoint\r\n\t{ get{ return _Store.Async(WorkQueueOnThreadPoolAdapter.Get()); } }\r\n}",
      "PostedDate": "2009-11-21T08:34:51.957-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-13T18:41:06.087-08:00",
      "Id": -2147483648
    }
  ]
}