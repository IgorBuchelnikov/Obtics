{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "I'm in the process of adding a weak event handler to all my ExpressionObserver.Execute statements for the purpose of accessing the GetEnumerator when the NotifyCollectionChanged event has an action of Reset.\n \nI just got the following exception.  Any idea what would cause it?  I believe it happened right after a collection change event with action=Replace.\n \nA first chance exception of type 'System.Collections.Generic.KeyNotFoundException' occurred in mscorlib.dll\nSystem.Windows.Data Error: 8 : Cannot save value from target back to source. BindingExpression:Path=Daily.RecurrenceRule.Interval; DataItem='RecurrenceViewModel' (HashCode=7080208); target element is 'TextBox' (Name=''); target property is 'Text' (type 'String') TargetInvocationException:'System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\n   at System.ThrowHelper.ThrowKeyNotFoundException()\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\n   at Obtics.Collections.Transformations.UnorderedCascadeTransformation`2.ProcessChildCollectionChangeNotification(BufferNodeCC bufferNode, INCollectionChangedEventArgs args) in \\Obtics\\Collections\\Transformations\\UnorderedCascadeTransformation.cs:line 440\n   at Obtics.Collections.Transformations.UnorderedCascadeTransformation`2.BufferNodeCC.NotifyChanged(Object sender, INCEventArgs changeArgs) in \\Obtics\\Collections\\Transformations\\UnorderedCascadeTransformation.cs:line 118\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCObservableObjectBase`1.Release(Object rawMessage) in \\Obtics\\NCObservableObjectBase.cs:line 187\n   at Obtics.Collections.Transformations.UnorderedCascadeTransformation`2.BufferNodeCC.NotifyChanged(Object sender, INCEventArgs changeArgs) in \\Obtics\\Collections\\Transformations\\UnorderedCascadeTransformation.cs:line 122\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCObservableObjectBase`1.Release(Object rawMessage) in \\Obtics\\NCObservableObjectBase.cs:line 187\n   at Obtics.Collections.Transformations.UnorderedCascadeTransformation`2.BufferNodeCC.NotifyChanged(Object sender, INCEventArgs changeArgs) in \\Obtics\\Collections\\Transformations\\UnorderedCascadeTransformation.cs:line 122\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCObservableObjectBase`1.Release(Object rawMessage) in \\Obtics\\NCObservableObjectBase.cs:line 187\n   at Obtics.Collections.Transformations.UnorderedCascadeTransformation`2.BufferNodeCC.NotifyChanged(Object sender, INCEventArgs changeArgs) in \\Obtics\\Collections\\Transformations\\UnorderedCascadeTransformation.cs:line 122\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 372\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 372\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCObservableObjectBase`1.Release(Object rawMessage) in \\Obtics\\NCObservableObjectBase.cs:line 187\n   at Obtics.Collections.Transformations.CascadeTransformation`2.BufferNodeCC.NotifyChanged(Object sender, INCEventArgs changeArgs) in \\Obtics\\Collections\\Transformations\\CascadeTransformation.cs:line 127\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCObservableObjectBase`1.Release(Object rawMessage) in \\Obtics\\NCObservableObjectBase.cs:line 187\n   at Obtics.Collections.Transformations.CascadeTransformation`2.BufferNodeCC.NotifyChanged(Object sender, INCEventArgs changeArgs) in \\Obtics\\Collections\\Transformations\\CascadeTransformation.cs:line 127\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs[] messages) in \\Obtics\\NCObservableObjectBase.cs:line 206\n   at Obtics.NCObservableObjectBase`1.Release(Object rawMessage) in \\Obtics\\NCObservableObjectBase.cs:line 189\n   at Obtics.Collections.Transformations.CascadeTransformation`2.BufferNodeCC.NotifyChanged(Object sender, INCEventArgs changeArgs) in \\Obtics\\Collections\\Transformations\\CascadeTransformation.cs:line 127\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 372\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.Collections.Transformations.OpaqueTransformationBase`3.Release(INCEventArgs message) in \\Obtics\\Collections\\Transformations\\OpaqueTransformationBase.cs:line 106\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObjectToVP`2.Release(INCEventArgs message) in \\Obtics\\NCSourcedObjectToVP.cs:line 144\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObjectToVP`2.Release(INCEventArgs message) in \\Obtics\\NCSourcedObjectToVP.cs:line 144\n   at Obtics.NCSourcedObject`1.NotifyChanged(Object sender, INCEventArgs args) in \\Obtics\\NCSourcedObject.cs:line 146\n   at Obtics.NotifyChangedReceiverTable.SendMessage(Object sender, INCEventArgs message) in \\Obtics\\NotifyChangedReceiverTable.cs:line 355\n   at Obtics.NCObservableObjectBase`1.Release(INCEventArgs message) in \\Obtics\\NCObservableObjectBase.cs:line 227\n   at Obtics.NCSourcedObjectToVP`2.Release(INCEventArgs message) in \\Obtics\\NCSourcedObjectToVP.cs:line 144\n   at Obtics.Values.Transformations.PropertyTransformation`2.Buffer_PropertyChanged(Object sender, EventArgs args) in \\Obtics\\Values\\Transformations\\PropertyTransformation.cs:line 212\n   at System.EventHandler.Invoke(Object sender, EventArgs e)\n   at System.ComponentModel.PropertyDescriptor.OnValueChanged(Object component, EventArgs e)\n   at System.ComponentModel.ReflectPropertyDescriptor.OnValueChanged(Object component, EventArgs e)\n   at System.ComponentModel.ReflectPropertyDescriptor.OnINotifyPropertyChanged(Object component, PropertyChangedEventArgs e)\n   at System.ComponentModel.PropertyChangedEventHandler.Invoke(Object sender, PropertyChangedEventArgs e)\n   at Npipm.ObjectModel.ObservableObject.NotifyPropertyChanged(String propertyName) in \\Npipm\\ObjectModel\\ObservableObject.vb:line 25\n   at Npipm.ObjectModel.ObservableObject.NotifyPropertyChanged[T](Expression`1 expression) in \\Npipm\\ObjectModel\\ObservableObject.vb:line 37\n   at CompasBiz.DateSeries.TakeByIntervalExpression.set_Interval(Int32 value) in \\Npipm.Compas.Scheduler\\Npipm.Compas.Scheduler\\Models\\Recurrence\\TakeExpressions.vb:line 47\n   at CompasBiz.DateSeries.RecurrenceRuleBase.set_Interval(Int32 value) in \\Npipm.Compas.Scheduler\\Npipm.Compas.Scheduler\\Models\\Recurrence\\RecurrenceRule.vb:line 206\n   --- End of inner exception stack trace ---\n   at System.RuntimeMethodHandle._InvokeMethodFast(Object target, Object[] arguments, SignatureStruct& sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner)\n   at System.RuntimeMethodHandle.InvokeMethodFast(Object target, Object[] arguments, Signature sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner)\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\n   at System.Reflection.RuntimePropertyInfo.SetValue(Object obj, Object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)\n   at System.Reflection.RuntimePropertyInfo.SetValue(Object obj, Object value, Object[] index)\n   at MS.Internal.Data.PropertyPathWorker.SetValue(Object item, Object value)\n   at MS.Internal.Data.ClrBindingWorker.UpdateValue(Object value)\n   at System.Windows.Data.BindingExpression.UpdateSource(Object value)'",
    "LastUpdatedDate": "2013-02-13T18:41:07.387-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "Obtics",
    "ReportedDate": "2009-09-24T11:55:33.187-07:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Exception",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 4987
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Are you sure it is necessairy to access the GetEnumerator when you receive the Reset events? Would it offer something usefull to the clients of your class?\r\n\r\nThe exception is very interesting. Can you reproduce it?\r\n\r\nIt means either a bug in Obtics or a key that changes identity. (For example, the key is a Person class, for equality between 2 Person objects you compare the Name properties and while a Person is being used as a key you change the name)\r\n\r\nRegs,\r\n\r\nThomas.",
      "PostedDate": "2009-09-24T16:10:09.223-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I am not yet sure if the access to GetEnumerator is required or not.  I'm still dealing with the issue of collections not updating when I think they should be updating, so I'm adding this GetEnumerator on a collection reset based on the advice of the thread http://obtics.codeplex.com/Thread/View.aspx?ThreadId=68881 in hopes that that will solve the issue.  However, I'm starting to think that may not be the problem I'm experiencing.",
      "PostedDate": "2009-09-25T06:47:09.27-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I recently checked in a fix for WorkItemId=4931 that you reported. Does that fix solve your problem?\r\n\r\nAccessing GetEnumerator would be needed only if you want to keep receiving events without being interested in the contents of the enumerable. (In which case by accessing GetEnumerator you just pretend to be interested). You might want this debugging reasons but to be honest, I can't think of another reason where this would be usefull.\r\n\r\nDid you check if your code has a class that uses some mutable property to test for equality? and uses it in a GetHashCode() override?",
      "PostedDate": "2009-09-25T08:12:48.23-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I'm pushing this bug aside for the moment because I think http://obtics.codeplex.com/WorkItem/View.aspx?WorkItemId=4990 is the root source of my problems.  I'm refactoring my app right now to use the working pattern listed in that bug report.\r\n\r\n> Accessing GetEnumerator would be needed only if you want to keep receiving events without being interested in the contents of the enumerable. (In which case by accessing GetEnumerator you just pretend to be interested). \r\n\r\nDoes this mean that an expression that has had .Cascade() called on it should never raise a Reset CollectionChanged event?  Otherwise, for example, if two lists are synchronized based on CollectionChanged events (which I do quite a bit to bind ItemsControl.SelectedItems to a list on a ViewModel), they would stop being synchronized after the Reset.",
      "PostedDate": "2009-09-25T10:33:10.197-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I'm pushing this bug aside for the moment because I think http://obtics.codeplex.com/WorkItem/View.aspx?WorkItemId=4990 is the root source of my problems.  I'm refactoring my app right now to use the working pattern listed in that bug report.\r\n\r\n> Accessing GetEnumerator would be needed only if you want to keep receiving events without being interested in the contents of the enumerable. (In which case by accessing GetEnumerator you just pretend to be interested). \r\n\r\nDoes this mean that an expression that has had .Cascade() called on it should never raise a Reset CollectionChanged event?  Otherwise, for example, if two lists are synchronized based on CollectionChanged events (which I do quite a bit to bind ItemsControl.SelectedItems to a list on a ViewModel), they would stop being synchronized after the Reset.",
      "PostedDate": "2009-09-25T10:35:25.107-07:00",
      "Id": -2147483648
    },
    {
      "Message": "You said:\r\n>Did you check if your code has a class that uses some mutable property to test for equality? and uses it in a GetHashCode() override?\r\n\r\nYes, my class overrides GetHashCode, which compares internal mutable properties.  It also implements IEquatable and overrides Object.Equals().",
      "PostedDate": "2009-09-25T12:32:07.203-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Yes workitem 4990 is very interesting. Working on it right now. \r\n\r\nStill: If you would synchronize a list base on CollectionChanged events comming from a .Cascade() generated object; (Yes, those too may send Reset events)\r\nthe proper action after receiving a Reset event would be to clear your list and fill it with the new contents. You would get these new contents by calling GetEnumerator(). In other words: keeping a list synchronized IMPLICITLY solves the no events issue.  \r\n\r\nAbout using mutable fields in your equality and hashcode generation: If in instance of such a class would be inserted into a hashtable (key in a dictionary) the hashcode would be used to determine in which bucket it would be placed. If then you would change the mutable field the result of the hashcode would change. So if then you would try to find the object again in the hashtable; the hashtable would look in the wrong bucket (determined by the new hashcode) and not find your object. \r\nCode should be written in such a way that for any object or value the HashCode never changes. And two objects or values that are equal according to your Equals method should always be equal and vice versa. Othwerwise you may run into problems not only with Obtics but also with the BCL.\r\n\r\nThat could explain the Exception you reported here. Note that Obtics could not find a key in a dictionary that it expected to be there.",
      "PostedDate": "2009-09-26T02:15:53.277-07:00",
      "Id": -2147483648
    },
    {
      "Message": "I tracked down the source of this bug.  The class the exception is talking about is different than what I thought it was, so my first statement about it overriding the hashcode was wrong.  It is actually a normal reference type.  The error occurs from a LINQ statement that selects the return value of a function that creates a new instance of the class each time it is called.  If I change that function to return a previously created reference if it has already been created once, then the error goes away.  When I get to work on Monday, I can give you better details, but it's something like this:\r\nfrom item in items select Me.CreateCopyOfItem(item)",
      "PostedDate": "2009-09-26T20:05:17.887-07:00",
      "Id": -2147483648
    },
    {
      "Message": "That is a good analysis. And you are right.\r\n\r\nAny lambda functions passed to obtics, or used in linq queries that are to be made observable should behave like mathematical functions in the sense that:\r\n\r\nSuppose M is a set of input paramers for the function F then:\r\n\r\nTResult r1 = F(M);\r\nTResult r2 = F(M);\r\n\r\ncomparer = EqualityComparer<TResult>.Default;\r\n\r\ncomparer.Equals(r1,r2) == true; //always\r\ncomparer.GetHashCode(r1) == comparer.GetHashCode(r2); //always\r\n\r\nNote that r1 and r2 do not necessarily need to be the same object instance.\r\n",
      "PostedDate": "2009-09-27T08:37:49.46-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-13T18:41:07.387-08:00",
      "Id": -2147483648
    }
  ]
}