[
  {
    "Id": "563706",
    "ThreadId": "245381",
    "Html": "\r\n<p>We've been getting an intermittent but serious error.&nbsp; Basically, sometimes we get a deadlock on one of our transformation changes, but sometimes we don't.</p>\r\n<p>It's when we're hooking up to a valueprovider's propertychanged event.&nbsp; Here's the stacktrace.</p>\r\n<p>&nbsp;&nbsp; at Obtics.ObservableObjectBase.Lock()<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.SubscribeINC(IReceiveChangeNotification receiver)<br>\r\n&nbsp;&nbsp; at Obtics.Collections.Transformations.NotifyVpcTransformation`2.Notifier..ctor(TType inItem, IValueProvider`1 valueProvider, NotifyVpcTransformation`2 owner)<br>\r\n&nbsp;&nbsp; at Obtics.Collections.Transformations.NotifyVpcTransformation`2.CreateNotifier(TType item, NotifyVpcTransformation`2 owner)<br>\r\n&nbsp;&nbsp; at Obtics.Collections.Transformations.NotifyVpcTransformation`2.RefreshBuffer()<br>\r\n&nbsp;&nbsp; at Obtics.Collections.Transformations.NotifyVpcTransformation`2.UpdateHaveChangedListeningClients(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.set_HaveChangedListeningClients(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.SubscribeINC(IReceiveChangeNotification receiver)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateNeedSourceChangedListener(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.set_NeedSourceChangedListener(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.RefreshHaveSourceChangedListener()<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateHaveChangedListeningClients(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.set_HaveChangedListeningClients(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.SubscribeINC(IReceiveChangeNotification receiver)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateNeedSourceChangedListener(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.set_NeedSourceChangedListener(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.RefreshHaveSourceChangedListener()<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateHaveChangedListeningClients(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.Collections.Transformations.ExtremityAggregateBase`5.UpdateHaveChangedListeningClients(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.set_HaveChangedListeningClients(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.SubscribeINC(IReceiveChangeNotification receiver)<br>\r\n&nbsp;&nbsp; at Obtics.Values.Transformations.CascadeTransformation`2.UpdateBuffer(IInternalValueProvider`1 newValue, IInternalValueProvider`1 oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.Values.Transformations.CascadingTransformationBase`5.set_Buffer(TItm value)<br>\r\n&nbsp;&nbsp; at Obtics.Values.Transformations.CascadingTransformationBase`5.RefreshBufferCache()<br>\r\n&nbsp;&nbsp; at Obtics.Values.Transformations.CascadingTransformationBase`5.UpdateHaveChangedListeningClients(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.set_HaveChangedListeningClients(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.SubscribeINC(IReceiveChangeNotification receiver)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateNeedSourceChangedListener(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.set_NeedSourceChangedListener(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.RefreshHaveSourceChangedListener()<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateHaveChangedListeningClients(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.set_HaveChangedListeningClients(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.SubscribeINC(IReceiveChangeNotification receiver)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateNeedSourceChangedListener(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.set_NeedSourceChangedListener(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.RefreshHaveSourceChangedListener()<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObject`1.UpdateHaveChangedListeningClients(Boolean newValue, Boolean oldValue)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.set_HaveChangedListeningClients(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCObservableObjectBase`1.SubscribeINC(IReceiveChangeNotification receiver)<br>\r\n&nbsp;&nbsp; at Obtics.NCToNPC.set_HavePropertyChangedListeningClients(Boolean value)<br>\r\n&nbsp;&nbsp; at Obtics.NCToNPC.add_PropertyChanged(PropertyChangedEventHandler value)<br>\r\n&nbsp;&nbsp; at Obtics.NCSourcedObjectToVP`2.add_PropertyChanged(PropertyChangedEventHandler value)</p>\r\n<p>Do you have any possible thoughts what this might be related to?&nbsp; Does the stack trace provide any clues that the untrained eye can't see?&nbsp; We're kinda stuck.</p>\r\n<p>Our only idea is to figure out a way to print out the transformation chain and see where the deadlock is coming from, but even that might not lead to the real answer.</p>\r\n<p>Note that the property we're seeing this on has no cycles visible in inspecting the code, and it actually works most of the time.</p>\r\n<p>Thoughts? :|</p>\r\n",
    "PostedDate": "2011-02-09T20:01:31.167-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "563801",
    "ThreadId": "245381",
    "Html": "\r\n<p>I assume you are using multiple threads in your application?</p>\r\n<p>What is the other thread (the one that is holding the lock)&nbsp;doing?</p>\r\n<p>Does this happen in one particular expression or is it a general problem?</p>\r\n<p>When a transformation 'pipeline' is queried for its value or change listeners are added (basicly any operation originating from client going (drilling)&nbsp;down&nbsp;to the source) the whole chain of transformations&nbsp;will get&nbsp;locked.</p>\r\n<p>Could it be that a thread that is drilling for a value (or collection) is triggering and waiting for&nbsp;your deadlocked&nbsp;thread to attach a change listener (it could even be the same thread)? If it does it should do this in a detached maner like via\r\n a dispatcher.</p>\r\n<p>It should be fine if all querying threads go from client to sources only. Deadlocks may happen if such a thread (or a thread it is waiting on) would re'enter from the top or cause a change notification to&nbsp;bubble up to the clients(modify a source by\r\n reading it). So obtics is threadsafe and concurrent but not re-entrant. (with the exception that on receiving a change notification you can drill for a value immediately). Naturally that is a 'should'. There might be a bug lurking.</p>\r\n",
    "PostedDate": "2011-02-10T01:28:19.273-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "564101",
    "ThreadId": "245381",
    "Html": "\r\n<p>Obtics is checking that the thread ids match before failing with the deadlock.</p>\r\n",
    "PostedDate": "2011-02-10T10:26:55.213-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "564509",
    "ThreadId": "245381",
    "Html": "<p>Do you mean that it is failing with an exception? Reporting \"Deadlock - transformation is its own source\"?</p>\r\n<p>That points to a dependency loop. You could create it like this:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">var</span> source = <span style=\"color: blue;\">new</span> ObservableCollection&lt;IEnumerable&lt;<span style=\"color: blue;\">int</span>&gt;&gt;();\r\n<span style=\"color: blue;\">var</span> trf = Obtics.Collections.ObservableEnumerable.Concat(source);\r\nsource.Add(trf);\r\n((INotifyCollectionChanged)trf).CollectionChanged += (s, e) =&gt; Console.Write(<span style=\"color: #a31515;\">\"changed\"</span>);</pre>\r\n<pre>Console.Write(trf.FirstOrDefault());\r\n</pre>\r\n</div>\r\n<p>The thread then&nbsp;should be in the same object somewhere further down the stack.</p>\r\n<p>Btw. It doesn't need to be a continuous trail of obtics methods in the stack. It could be interspersed with system or your own code.&nbsp;</p>\r\n<p>Neither does it need to be direct. Might be for example&nbsp;that accessing a property that is the source of a tansformation pipeline triggers a lazy initialization of an object where some part of the initialization accesses the same or part of the same&nbsp;pipeline.</p>",
    "PostedDate": "2011-02-11T02:42:33.66-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]