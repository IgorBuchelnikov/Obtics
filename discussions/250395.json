[
  {
    "Id": "583194",
    "ThreadId": "250395",
    "Html": "\r\n<p>I've been building some recursive select methods for use with Obtics. &nbsp;It had been going fairly well with the following methods working:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>IEnumerable&lt;T&gt; SelectRecursive(T source, Func&lt;T,T&gt; selector)\r\nIEnumerable&lt;T&gt; SelectManyRecursive(T source, Func&lt;T,IEnumerable&lt;T&gt;&gt; selector)\r\nIEnumerable&lt;T&gt; SelectManyRecursive(IEnumerable&lt;T&gt; source, Func&lt;T,IEnumerable&lt;T&gt;&gt; selector)\r\n</pre>\r\n</div>\r\n<p>Unfortunately, when I got to the SelectManyRecursiveCyclic method, designed to handle cycles, things fell apart. &nbsp;I got a Linq expression to do the recursive select many and avoid cycles, but when I tried to make it observable, Obtics overflowed the\r\n stack when doing ExpressionObserver.Compile(). &nbsp;It didn't even care what the data was like.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:green\">// [SelectManyRecursive] Works, but doesn't handle cycles.</span>\r\n(IEnumerable&lt;T&gt; s, Func&lt;T, IEnumerable&lt;T&gt;&gt; sel) =&gt;\r\n\ts.Concat(s.SelectMany(t =&gt; sel(t).Except(s).SelectManyRecursive(sel))));\r\n\r\n<span style=\"color:green\">// [SelectManyRecursiveCyclic] Expression works to handle cycles in plain Linq, but causes stack overflow when setting up with ExpressionObserver.Compile()</span>\r\n(IEnumerable&lt;T&gt; s, Func&lt;T, IEnumerable&lt;T&gt;&gt; sel) =&gt;\r\n\ts.SelectMany(sel).Except(s).Transform(t =&gt; t.Any() ? s.Concat(t).SelectManyRecursiveCyclic(sel) : s));\r\n</pre>\r\n</div>\r\n<p>I've tried many variations of the expression, all with the same result. &nbsp;I'm at a bit of a loss as to how to make this recursive cycle-avoiding thing work. &nbsp;I don't understand why Obtics seems to be creating inifinitely deep chains without even\r\n looking at the data. &nbsp;Any thoughts? &nbsp;I'm out of ideas at this point. :(</p>\r\n<p>Appreciate any insight you might be able to offer.</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2011-03-19T22:32:42.9-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "583869",
    "ThreadId": "250395",
    "Html": "<p>If I understood the intention of your SelectManyRecursiveCyclic method correctly, this is how I think I would implement it (not tested):</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><div style=\"color: black; background-color: white;\"><pre><span style=\"color: blue;\">using</span> System;\r\n<span style=\"color: blue;\">using</span> System.Collections.Generic;\r\n<span style=\"color: blue;\">using</span> System.Text;\r\n<span style=\"color: blue;\">using</span> Obtics.Values;\r\n<span style=\"color: blue;\">using</span> Obtics.Collections;\r\n\r\n<span style=\"color: blue;\">namespace</span> Test2\r\n{\r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> <span style=\"color: blue;\">class</span> SomeMethods\r\n    {\r\n        <span style=\"color: blue;\">static</span> IValueProvider&lt;IEnumerable&lt;T&gt;&gt; Recurse&lt;T&gt;(Tuple&lt;IEnumerable&lt;T&gt;, IEnumerable&lt;T&gt;&gt; t, Func&lt;Tuple&lt;IEnumerable&lt;T&gt;, IEnumerable&lt;T&gt;&gt;, Tuple&lt;IEnumerable&lt;T&gt;, IEnumerable&lt;T&gt;&gt;&gt; proc)\r\n        {\r\n            <span style=\"color: blue;\">var</span> newT = proc(t);\r\n            <span style=\"color: blue;\">return</span> newT.Item2.Any().Select( anyNew =&gt; anyNew ? Recurse(newT, proc) : ValueProvider.Static(newT.Item1) );\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> IEnumerable&lt;T&gt; SelectManyRecursiveCyclic&lt;T&gt;(<span style=\"color: blue;\">this</span> IEnumerable&lt;T&gt; source, Func&lt;T, IEnumerable&lt;T&gt;&gt; <span style=\"color: blue;\">select</span>)\r\n        {\r\n            <span style=\"color: blue;\">var</span> distinctedSource = source.Distinct();\r\n\r\n            <span style=\"color: blue;\">return</span>\r\n                Recurse(\r\n                    <span style=\"color: green;\">//Item1 = distinct elements collected sofar, Item2 = elements not traversed yet with select method</span>\r\n                    Tuple.Create(System.Linq.Enumerable.Empty&lt;T&gt;(), distinctedSource),\r\n                    t =&gt;\r\n                    {\r\n                        <span style=\"color: blue;\">var</span> sofar = t.Item1.Concat(t.Item2);\r\n                        <span style=\"color: blue;\">var</span> newElts = t.Item2.SelectMany(<span style=\"color: blue;\">select</span>).Except(sofar);\r\n\r\n                        <span style=\"color: blue;\">return</span> Tuple.Create(\r\n                            sofar,\r\n                            newElts\r\n                        );\r\n                    }\r\n                )\r\n                .Cascade()\r\n            ;\r\n        }\r\n        \r\n    }\r\n}\r\n\r\n</pre>\r\n</div>\r\nWhen does the observer stack overflow? I can imagine it could do that when actually building a</pre>\r\n<pre>transformation tree. Note that an \"b ? T : F\" expression <strong>when rewritten</strong> may not only follow the </pre>\r\n<pre>T or F branch but <strong>both.</strong> it may build a transformation subtree for the T value provider <strong>and</strong> a transformation </pre>\r\n<pre>subtree for the F value provider. If in that case there is a recursion for either the T or F branch it</pre>\r\n<pre>will try to build an infinitly large transformation tree.</pre>\r\n<pre>It would be very iteresting if the CollectionObserver would stack overflow while doing a rewriting. In that </pre>\r\n<pre>case, could you send some code that does this?</pre>\r\n</div>",
    "PostedDate": "2011-03-21T11:02:14.137-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "583912",
    "ThreadId": "250395",
    "Html": "<p>I ended up coming up with the dual list approach myself as well later on.&nbsp; This code worked for me.</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>[ExpressionObserverMapping(<span style=\"color: blue;\">typeof</span>(Observable))]\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> IEnumerable&lt;T&gt; SelectManyRecursiveCyclic&lt;T&gt;(<span style=\"color: blue;\">this</span> IEnumerable&lt;T&gt; source, Func&lt;T, IEnumerable&lt;T&gt;&gt; selector)\r\n{\r\n    <span style=\"color: blue;\">return</span> source.SelectManyUsed(Enumerable.Empty&lt;T&gt;(), selector).Distinct();\r\n}\r\n\r\n[ExpressionObserverMapping(<span style=\"color: blue;\">typeof</span>(Observable))]\r\n<span style=\"color: blue;\">private</span> <span style=\"color: blue;\">static</span> IEnumerable&lt;T&gt; SelectManyUsed&lt;T&gt;(<span style=\"color: blue;\">this</span> IEnumerable&lt;T&gt; source, IEnumerable&lt;T&gt; used, Func&lt;T, IEnumerable&lt;T&gt;&gt; selector)\r\n{\r\n    <span style=\"color: blue;\">return</span> source.Concat(source.SelectMany(t =&gt; selector(t).Except(used).SelectManyUsed(used.Concat(<span style=\"color: blue;\">new</span>[] { t }), selector)));\r\n}\r\n<br />Here is some code that produces the stack overflow.  I don't recall what the nature of the overflow was.<br /><br /><div style=\"color: black; background-color: white;\"><pre>[ExpressionObserverMapping(<span style=\"color: blue;\">typeof</span>(Observable))]\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> IEnumerable&lt;T&gt; SelectManyRecursiveCyclic&lt;T&gt;(<span style=\"color: blue;\">this</span> IEnumerable&lt;T&gt; source, Func&lt;T, IEnumerable&lt;T&gt;&gt; selector)\r\n{\r\n\t<span style=\"color: blue;\">return</span> source.SelectMany(selector).Except(source).Transform(t =&gt; t.Any() ? source.Concat(t).SelectManyRecursiveCyclic(selector) : source);\r\n}\r\n\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> <span style=\"color: blue;\">class</span> Observable\r\n{\r\n\t<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> IEnumerable&lt;T&gt; SelectManyRecursiveCyclic&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, IEnumerable&lt;T&gt;&gt; selector)\r\n\t{\r\n\t\t<span style=\"color: blue;\">return</span> ObservableGeneric&lt;T&gt;.SelectManyRecursiveCyclic(source, selector);\r\n\t}\r\n}\r\n\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> <span style=\"color: blue;\">class</span> ObservableGeneric&lt;T&gt;\r\n{\r\n\t<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">static</span> IEnumerable&lt;T&gt; SelectManyRecursiveCyclic(IEnumerable&lt;T&gt; source, Func&lt;T, IEnumerable&lt;T&gt;&gt; selector)\r\n\t{\r\n\t\t<span style=\"color: blue;\">if</span> (_selectManyRecursiveCyclicFunc == <span style=\"color: blue;\">null</span>)\r\n\t\t{\r\n\t\t\t_selectManyRecursiveCyclicFunc = ExpressionObserver.Compile((IEnumerable&lt;T&gt; s, Func&lt;T, IEnumerable&lt;T&gt;&gt; sel) =&gt;\r\n\t\t\t\ts.SelectMany(sel).Except(s).Transform(t =&gt; t.Any() ? s.Concat(t).SelectManyRecursiveCyclic(sel) : s));\r\n\t\t}\r\n\t\t<span style=\"color: blue;\">return</span> _selectManyRecursiveCyclicFunc(source, selector).Cascade();\r\n\t}\r\n\t<span style=\"color: blue;\">private</span> <span style=\"color: blue;\">static</span> Func&lt;IEnumerable&lt;T&gt;, Func&lt;T, IEnumerable&lt;T&gt;&gt;, IValueProvider&lt;IEnumerable&lt;T&gt;&gt;&gt; _selectManyRecursiveCyclicFunc;\r\n}\r\n</pre>\r\n</div>\r\n</pre>\r\n</div>\r\n</p>",
    "PostedDate": "2011-03-21T12:20:44.34-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "585586",
    "ThreadId": "250395",
    "Html": "<p>Yes, whatever works.</p>\r\n<p>A few small things though; seeing the level you are working at it may be better not to work via ExpressionObserver.Compile. Rewritten expressions will always be eagerly change aware, possibly&nbsp;looking and reserving resources&nbsp;for changes the will never happen. It may be better if you would use ObservableEnumerable methods directly. I gives you direct control over how the transformation tree is built.</p>\r\n<p>In the SelectManyUsed method you do a selector(t).Except(used).SelectManyUsed( .. etc. for every element in the source. Might it not be beter to first collect all new elements (like you actually do in SelectManyRecursiveCyclic) and the do the Except rule etc. on the entire collection of new elements?</p>\r\n<p>Transformation pipelines/tree are not cheap so, if you are working on core methods, it&nbsp;would be&nbsp;best to minimize their size.</p>",
    "PostedDate": "2011-03-24T03:40:57.99-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]