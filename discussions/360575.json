[
  {
    "Id": "852499",
    "ThreadId": "360575",
    "Html": "\r\n<p>Hi,</p>\r\n<p>I have a scenario with a ListBox bound to a collection of ViewModels. This collection is actually a Obtics expression that binds further to a model. The model is changed by a background thread, so I use the WorkQueueOnDispatcherProvider to make sure the\r\n viewmodels are updated on the UI thread.</p>\r\n<p>Adding items works perfectly fine, but removing them throws an InvalidOperationException in the ListBox (with strange message &quot;Added item does not appear at given index&quot;).</p>\r\n<p>I have no idea what I am doing wrong. Please help me.</p>\r\n<p>I created a minimal example to reproduce the behaviour:</p>\r\n<p>&nbsp;internal class MainViewModel<br>\r\n&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private readonly Model dummyModel;<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for binding to a ListBox<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IEnumerable&lt;ItemViewModel&gt; ItemCollection { get; private set; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public MainViewModel()<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dummyModel = new Model {Items = new ObservableCollection&lt;string&gt;()};<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dummyModel.Items.Add(&quot;hello&quot;);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dummyModel.Items.Add(&quot;world&quot;);<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IValueProvider&lt;IEnumerable&lt;string&gt;&gt; valueProvider =<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpressionObserver.Execute(() =&gt; Enumerable.Select(dummyModel.Items, s =&gt; s));<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //from what I figured out, I have to call Async() before I create the final ItemCollection expression so that<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //CreateViewModel() is called in the UI thread.<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEnumerable&lt;string&gt; modelItems =<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valueProvider.Cascade().Async(new WorkQueueOnDispatcherProvider().GetWorkQueue());<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ItemCollection =<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpressionObserver.Execute(() =&gt; Enumerable.Select(modelItems, s =&gt; CreateViewModel(s))).Cascade();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private static ItemViewModel CreateViewModel(string s)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //this MUST be called in the UI thread because I access some thread-affine objects in my real application.<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new ItemViewModel {Text = s};<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void StartOperation()<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task.Factory.StartNew(<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; () =&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.Sleep(1000);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dummyModel.Items.RemoveAt(1);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //dummyModel.Items.Add(&quot;hello&quot;);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp; internal class ItemViewModel<br>\r\n&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string Text { get; set; }<br>\r\n&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp; internal class Model<br>\r\n&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ObservableCollection&lt;string&gt; Items { get; set; }<br>\r\n&nbsp;&nbsp;&nbsp; }</p>\r\n<p>And the necessary XAML part:</p>\r\n<p>&nbsp;&lt;Window.Resources&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ResourceDictionary&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;WpfApplication1:MainViewModel x:Key=&quot;myMainViewModel&quot;&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/WpfApplication1:MainViewModel&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/ResourceDictionary&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;/Window.Resources&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;StackPanel DataContext=&quot;{StaticResource ResourceKey=myMainViewModel}&quot;&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Button Click=&quot;Clicked&quot;&gt;Start Remove&lt;/Button&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ListBox ItemsSource=&quot;{Binding Path=ItemCollection}&quot;&gt;&lt;/ListBox&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;/StackPanel&gt;</p>\r\n",
    "PostedDate": "2012-06-22T02:16:03.71-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "853461",
    "ThreadId": "360575",
    "Html": "<p>Hi,</p>\r\n<p>Problem is that Select(modelItems, s =&gt; CreateViewModel(s)) uses the lambda expression both for adding and removing items. So; CreateViewModel(s) gets called when an item is added and when an item is removed. Now; if CreateViewModel(s) does not return an&nbsp;equal object every time it gets called with the same s then it means that a different object will be removed than was originaly added -&gt; error.</p>\r\n<p>You should create a method GetViewModel(s) instead of CreateViewModel(s), like:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>TvdP.Collections.WeakValueDictionary&lt;<span style=\"color: blue;\">string</span>,ItemViewModel&gt; _registry = <span style=\"color: blue;\">new</span> TvdP.Collections.WeakValueDictionary&lt;<span style=\"color: blue;\">string</span>,ItemViewModel&gt;()\r\n\r\n<span style=\"color: blue;\">private</span> <span style=\"color: blue;\">static</span> ItemViewModel GetViewModel(<span style=\"color: blue;\">string</span> s)\r\n        {\r\n            <span style=\"color: green;\">//this MUST be called in the UI thread because I access some thread-affine objects in my real application.</span>\r\n            <span style=\"color: blue;\">return</span> _registry.GetOrAdd(s, s2 =&gt; <span style=\"color: blue;\">new</span> ItemViewModel {Text = s2});\r\n        }\r\n\r\n</pre>\r\n</div>",
    "PostedDate": "2012-06-25T16:17:51.54-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "853965",
    "ThreadId": "360575",
    "Html": "<p>Many thanks, that did it.</p>",
    "PostedDate": "2012-06-26T11:10:14.663-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]